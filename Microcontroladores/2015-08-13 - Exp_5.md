##Exercicio 1
1. Abra um novo projeto para o firmware abaixo, compile, grave o chip e realize os testes na placa PICgenius. Este programa um contador de segundos baseado na interrupção por tempo gerada pela reinicialização do temporizador zero (Timer 0). Toques na tecla RB3 definem se o contador é ligado ou desligado. Estando o contador inicialmente desligado, o primeiro toque liga, o segundo toque desliga, e assim sucessivamente.
Quando o contador estiver ligado, o display de 7 segmentos número 4 (DIS4) irá contar de zero a nove e repetir esse procedimento até que o contador seja desligado.
Os procedimentos para utilização do MPLAB IDE, PIC Kit 2, Micro ICD ZIF e PICgenius estão disponíveis no procedimento experimental da experiência 1. Ainda na PICgenius você precisa reconfigurar algumas posições das Chaves de Funções (Dip Switches) como segue:

- Chave da Esquerda: todas as posições desligadas.
- Chave da Direita: todas as posições desligadas, exceto posição DIS4 – RA5 em ON.

```assembly_x86
; 1. CABEÇALHO DE IDENTIFICAÇÃO

;FIAP
;MICROPROCESSADORES
;EXERCÍCIO 5

; 2. ARQUIVO DE DEFINIÇÃO DO MICROCONTROLADOR

#INCLUDE <P18F452.INC>

; 3. DEFINIÇÃO DE VARIÁVEIS

; 3.1 GERAIS

CBLOCK 0x80				; ENDEREÇO INICIAL DA MEMÓRIA DE DADOS
			FILTRO			; VARIÁVEL FILTRO PARA O BOTÃO
			; ABAIXO SÃO CRIADAS VARIÁVEIS PARA AS INTERRUPÇÕES
			W_TEMP			; VARIÁVEL PARA ARMAZENAR O CONTEXTO
								; ATUAL DO REGISTRADOR WORK
			STATUS_TEMP		; VARIÁVEL PARA ARMAZENAR O CONTEXTO
								; ATUAL DO REGISTRADOR STATUS
			TEMPO				; ARMAZENA O VALOR DO TEMPO
			FLAGS				; FLAGS DE CONTROLE
			TEMP1				; VARIÁVEIS AUXILIARES
			CONTADOR		; VARIÁVEL COM O VALOR QUE APARECE NO DISPLAY
ENDC						; FIM DO BLOCO

; 3.2 FLAGS

#DEFINE ST_BT_RB3 FLAGS,0	; FLAG DE ESTADO DO BOTÃO RB3

; 3.3 CONSTANTES

V_INICIO EQU .1			; VALOR INICIAL DO TIMER (1 SEGUNDO)
T_FILTRO EQU .230		; CONSTANTE T_FILTRO COM 230 DECIMAL
MAX EQU .10				; VALOR MÁXIMO + 1 PARA O CONTADOR

; 3.4 I/Os

#DEFINE BOTAO_RB3 PORTB,3	; PORTB = BIT 3 (RB3)
									; SITUAÇÕES LÓGICAS: 	0 = PRESSIONADO
									;							1 = LIBERADO
#DEFINE DISP4 PORTA,5			; PINO DE HABILITAÇÃO DO DISP 4 (RA5)

;#DEFINE LED_D0 PORTD,0			; LED D0
;#DEFINE LED_D1 PORTD,1			; LED D1

; 4. VETOR DE RESET

ORG 0x00
GOTO INICIO

; 5. TRATAMENTO DAS INTERRUPÇÕES
; INÍCIO

	ORG 0x04		; VETOR DE INTERRUPÇÃO

	; A SEGUIR GUARDA CONTEXTO ATUAL DO WORK E DO STATUS
	MOVWF W_TEMP			; COPIA O WORK NA VARIÁVEL W_TEMP
	SWAPF STATUS,W			; GUARDA O VALOR DO STATUS NO WORK
							; INVERTENDO OS NIBBLES; BLOQUEIA MUDANÇAS NO STATUS
	MOVWF STATUS_TEMP	; COPIA O WORK NA VARIÁVEL STATUS_TEMP

	; A SEGUIR AVALIA QUAL TIPO DE INTERRUPÇÃO OCORREU

	BTFSS INTCON,TMR0IF	; OCORREU INTERRUPÇÃO DO TIMER 0?
	GOTO SAI_INT				; NÃO, SAI DO TRATAMENTO
								; SIM, INICIA TRATAMENTO

	; TRATAMENTO DA INTERRUPÇÃO DO TIMER 0
	; ESTA ROTINA IRÁ CONTAR O TEMPO, E QUANDO PASSAR 1 SEGUNDO, A VARIÁVEL
	; TEMPO SERÁ DECREMENTADA
	; 1 SEGUNDO = 64us (PRESCALER) x 125 (TMR0) x 125 (TEMP1)

	BCF INTCON, TMR0IF		; LIMPA A FLAG TMR0IF, REABILITANDO A INDICAÇÃO DE NOVAS INT.
	MOVLW .256-.125			; COLOCA NO WORK UM LITERAL IGUAL A 256 - 125
	MOVWF TMR0				; REINICIA O TIMER 0, COPIANDO O VALOR DO WORK PARA TMR0
	DECFSZ TEMP1,F			; DECREMENTA VARIÁVEL AUXILIAR. ACABOU?
	GOTO SAI_INT				; SE NÃO, SAI DO TRATAMENTO
								; SE SIM, CONTINUA
	MOVLW .125				; COLOCA 125 NO WORK
	MOVWF TEMP1				; REINICIALIZA A VARIÁVEL TEMP1 COM 125
	
	DECFSZ TEMPO,F			; DECREMENTA TEMPO. ACABOU ?
	GOTO SAI_INT				; SE NÃO, SAI DO TRATAMENTO
								; SE SIM, CONTINUA
	MOVLW V_INICIO
	MOVWF TEMPO			; REINICIALIZA A VARIÁVEL TEMPO COM V_INICIO

	INCF CONTADOR,F			; INCREMENTA CONTADOR. RESULTADO NO CONTADOR
	MOVF CONTADOR,W		; MOVE CONTADOR PARA O WORK
	XORLW MAX				; REALIZA OPERAÇÃO OU EXCLUSIVO ENTRE O VALOR ATUAL
								; DO CONTADOR E O VALOR MÁXIMO + 1 (NO CASO = 10)
								; PARA TESTAR IGUALDADE. SE FOREM IGUAIS
								; O RESUTADO SERÁ ZERO
	BTFSS STATUS,Z			; AVALIA O BIT Z DO STATUS
	GOTO ATUALIZA			; SE FOR ZERO, PULA PARA ATUALIZA
	CLRF CONTADOR			; SE FOR 1, ZERA O CONTADOR

	ATUALIZA
	CALL CONVERTE			; CHAMA A ROTINA DE CONVERSÃO DO VALOR DO CONTADOR
								; PARA QUE OS SEGMENTOS DO DISPLAY ACENDAM CORRETAMENTE
	MOVWF PORTD			; ATUALIZA PORTD PARA QUE O VALOR DO CONTADOR
								; SEJA VISUALIZADO NO DISPLAY

	SAI_INT
	
	; RECUPERA O CONTEXTO SALVO
	SWAPF STATUS_TEMP,W	; ARMAZENA VARIÁVEL STATUS_TEMP NO WORK
								; INVERTENDO OS NIBBLES
	MOVWF STATUS			; RECUPERA O STATUS
	SWAPF W_TEMP,F			
	SWAPF W_TEMP,W		; RECUPERA O WORK, UTILIZANDO SWAPF PARA
								; NÃO DEIXAR O WORK SER ALTERADO COM O RETFIE
	RETFIE						; RETORNA DA INTERRUPÇÃO 

; FIM DO TRATAMENTO DAS INTERRUPÇÕES

; 6. ROTINAS

	; 6.1 ROTINA PARA LIGAR O TIMER 0

		LIGA_TIMER
		CALL CONVERTE		; CHAMA ROTINA DE CONVERSÃO DA VARIÁVEL CONTADOR
								; PARA ACIONAMENTO DO DISPLAY COM O VALOR ZERO
		MOVWF PORTD		; MOVE O CONTEÚDO DE RETORNO DA ROTINA CONVERTE
								; DO WORK PARA O PORTD
		BSF DISP4				; LIGA DISP4

		BCF INTCON,TMR0IF	; LIMPA FLAG DE INT. DO TMR0
		MOVLW .256-.125		; MOVE O LITERAL 256-125 AO WORK
		MOVWF TMR0			; INICIA O TMR0 COM 256-125
		MOVLW .125			; MOVE 125 AO WORK
		MOVWF TEMP1			; INICIA TEMP1 COM 125
		BSF INTCON,GIE		; LIGA CHAVE GERAL DE INT.
		
		RETURN
		
	; 6.2 ROTINA PARA DESLIGAR O TIMER 0

		DESLIGA_TIMER
		BCF INTCON,GIE		; DESLIGA CHAVE GERAL DE INT.
		BCF DISP4				; DESLIGA DISP4
		CLRF CONTADOR		; LIMPA CONTADOR
		RETURN	
 
	; 6.3 ROTINA DE CONVERSÃO BINÁRIO - DISPLAY DE SEGMENTOS
		
		CONVERTE

		MOVLW B'00000000'	; CARREGA ZERO NO WORK
		XORWF CONTADOR,W	; OU EXCLUSIVO ENTRE O WORK E CONTADOR
								; SE FOREM IGUAIS O RESUTADO SERÁ ZERO
		BTFSS STATUS,Z		; AVALIA O BIT Z DO STATUS
		GOTO NEXT_1			; SE FOR ZERO, PULA PARA NEXT_1
		RETLW B'00111111'	; RETORNA DÍGITO 0 NO WORK
		
		NEXT_1
		MOVLW B'00000001'	; CARREGA 1 NO WORK
		XORWF CONTADOR,W	; OU EXCLUSIVO ENTRE O WORK E CONTADOR
								; SE FOREM IGUAIS O RESUTADO SERÁ ZERO
		BTFSS STATUS,Z		; AVALIA O BIT Z DO STATUS
		GOTO NEXT_2			; SE FOR ZERO, PULA PARA NEXT_1
		RETLW B'00000110'	; RETORNA DÍGITO 1 NO WORK
		
		NEXT_2
		MOVLW B'00000010'	; CARREGA 2 NO WORK
		XORWF CONTADOR,W	; OU EXCLUSIVO ENTRE O WORK E CONTADOR
								; SE FOREM IGUAIS O RESUTADO SERÁ ZERO
		BTFSS STATUS,Z		; AVALIA O BIT Z DO STATUS
		GOTO NEXT_3			; SE FOR ZERO, PULA PARA NEXT_1
		RETLW B'01011011'	; RETORNA DÍGITO 2 NO WORK
		
		NEXT_3
		MOVLW B'00000011'	; CARREGA 3 NO WORK
		XORWF CONTADOR,W	; OU EXCLUSIVO ENTRE O WORK E CONTADOR
								; SE FOREM IGUAIS O RESUTADO SERÁ ZERO
		BTFSS STATUS,Z		; AVALIA O BIT Z DO STATUS
		GOTO NEXT_4			; SE FOR ZERO, PULA PARA NEXT_1
		RETLW B'01001111'	; RETORNA DÍGITO 3 NO WORK
		
		NEXT_4
		MOVLW B'00000100'	; CARREGA 4 NO WORK
		XORWF CONTADOR,W	; OU EXCLUSIVO ENTRE O WORK E CONTADOR
								; SE FOREM IGUAIS O RESUTADO SERÁ ZERO
		BTFSS STATUS,Z		; AVALIA O BIT Z DO STATUS
		GOTO NEXT_5			; SE FOR ZERO, PULA PARA NEXT_1
		RETLW B'01100110'	; RETORNA DÍGITO 4 NO WORK
		
		NEXT_5
		MOVLW B'00000101'	; CARREGA 5 NO WORK
		XORWF CONTADOR,W	; OU EXCLUSIVO ENTRE O WORK E CONTADOR
								; SE FOREM IGUAIS O RESUTADO SERÁ ZERO
		BTFSS STATUS,Z		; AVALIA O BIT Z DO STATUS
		GOTO NEXT_6			; SE FOR ZERO, PULA PARA NEXT_1
		RETLW B'01101101'	; RETORNA DÍGITO 5 NO WORK
		
		NEXT_6
		MOVLW B'00000110'	; CARREGA 6 NO WORK
		XORWF CONTADOR,W	; OU EXCLUSIVO ENTRE O WORK E CONTADOR
								; SE FOREM IGUAIS O RESUTADO SERÁ ZERO
		BTFSS STATUS,Z		; AVALIA O BIT Z DO STATUS
		GOTO NEXT_7			; SE FOR ZERO, PULA PARA NEXT_1
		RETLW B'01111101'	; RETORNA DÍGITO 6 NO WORK
		
		NEXT_7
		MOVLW B'00000111'	; CARREGA 7 NO WORK
		XORWF CONTADOR,W	; OU EXCLUSIVO ENTRE O WORK E CONTADOR
								; SE FOREM IGUAIS O RESUTADO SERÁ ZERO
		BTFSS STATUS,Z		; AVALIA O BIT Z DO STATUS
		GOTO NEXT_8			; SE FOR ZERO, PULA PARA NEXT_1
		RETLW B'00000111'	; RETORNA DÍGITO 7 NO WORK
		
		NEXT_8
		MOVLW B'00001000'	; CARREGA 8 NO WORK
		XORWF CONTADOR,W	; OU EXCLUSIVO ENTRE O WORK E ZERO
								; SE FOREM IGUAIS O RESUTADO SERÁ ZERO
		BTFSS STATUS,Z		; AVALIA O BIT Z DO STATUS
		GOTO NEXT_9			; SE FOR ZERO, PULA PARA NEXT_1
		RETLW B'01111111'	; RETORNA DÍGITO 8 NO WORK
		
		NEXT_9
		MOVLW B'00001001'	; CARREGA 9 NO WORK
		XORWF CONTADOR,W	; OU EXCLUSIVO ENTRE O WORK E CONTADOR
								; SE FOREM IGUAIS O RESUTADO SERÁ ZERO
		BTFSS STATUS,Z		; AVALIA O BIT Z DO STATUS
		GOTO NEXT_10		; SE FOR ZERO, PULA PARA NEXT_1
		RETLW B'01101111'	; RETORNA DÍGITO 9 NO WORK
		
		NEXT_10
		RETURN

; 7. INÍCIO DO PROGRAMA
; CONFIGURAÇÕES INICIAIS (REGISTRADORES DE FUNÇÕES ESPECIAIS)

INICIO

	CLRF PORTB			; LIMPA PORTB (ESCREVE ZERO EM TODOS OS PINOS DO PORTB)
	CLRF PORTD			; LIMPA PORTD (ESCREVE ZERO EM TODOS OS PINOS DO PORTD)
	CLRF PORTA			; LIMPA PORTA (ESCREVE ZERO EM TODOS OS PINOS DO PORTA)
	MOVLW 0x07 			; CONFIGURA CONVERSORES A/D
	MOVWF ADCON1 		; PARA ENTRADAS DIGITAIS

	CLRF FLAGS			; LIMPA VARIÁVEL FLAGS
	CLRF CONTADOR		; LIMPA VARIÁVEL CONTADOR
	
	MOVLW V_INICIO		; MOVE CONSTANTE V_INICIO PARA O WORK
	MOVWF TEMPO		; INICIA TEMPO = V_INICIO

	MOVLW B'00001000' 	; MOVE O VALOR BINÁRIO PARA O REGISTRADOR WORK
	MOVWF TRISB 			; DEFINE RB3 COMO ENTRADA E DEMAIS COMO SAÍDA

	MOVLW B'00000000' 	; MOVE O VALOR BINÁRIO PARA O REGISTRADOR WORK
	MOVWF TRISD 			; DEFINE TODOS OS TERMINAIS DO PORTD COMO SAÍDA

	MOVLW B'00000000' 	; MOVE O VALOR BINÁRIO PARA O REGISTRADOR WORK
	MOVWF TRISA 			; DEFINE TODOS OS TERMINAIS DO PORTA COMO SAÍDA

	MOVLW B'11000110' 	; MOVE O VALOR BINÁRIO PARA O REGISTRADOR WORK
	MOVWF T0CON 		; LIGA TMR0, PRESCALER EM 1:128 (64us); CONTAGEM DE 8 BITS

	MOVLW B'00100000' 	; MOVE O VALOR BINÁRIO PARA O REGISTRADOR WORK
	MOVWF INTCON 		; HABILITA INTERRUPÇÃO DO TMR0
							; CHAVE GERAL DAS INTERRUPÇÕES DESLIGADAS
		 
; 8. FUNÇÃO PRINCIPAL

MAIN

	MOVLW T_FILTRO
	MOVWF FILTRO		; INICIA O FILTRO (FILTRO = T_FILTRO)

VERIFICA_1_BT

	BTFSC BOTAO_RB3      ; O BOTÃO ESTÁ PRESSIONADO?
       GOTO MAIN			; NÃO, ENTÃO CONTINUE ESPERANDO
	DECFSZ FILTRO,1		; SIM, ENTÃO DECREMENTA O FILTRO DO BOTÃO
	GOTO VERIFICA_1_BT

	BTFSC ST_BT_RB3		; VERIFICA FLAG DE SITUAÇÃO DO BOTÃO RB3
	GOTO TIMER_OFF			; SE FOR 1, TIMER DEVE SER DESLIGADO
								; SE FOR 0, CONTINUA			

	BSF ST_BT_RB3			; MARCA FLAG DO BOTÃO RB3 COMO PRESSIONADO
	CALL LIGA_TIMER			; CHAMA ROTINA PARA LIGAR O TIMER
	GOTO VERIFICA_2_BT

TIMER_OFF
	BCF ST_BT_RB3			; MARCA FLAG DO BOTAO RB3 COMO SOLTO
	CALL DESLIGA_TIMER		; CHAMA ROTINA PARA DESLIGAR O TIMER

VERIFICA_2_BT
	
	BTFSS BOTAO_RB3     ; O BOTÃO ESTÁ PRESSIONADO?
	GOTO VERIFICA_2_BT	; SIM, ENTÃO CONTINUE AVALIANDO
	GOTO MAIN			; NÃO, ENTÃO VOLTE AO LOOP PRINCIPAL

END 					; FIM DO PROGRAMA
```

##Exercicio 2
2. Aproveitando a estrutura do exemplo, acrescente mais um display (DISP 3) que deverá trabalhar para a casa de
dezenas. Você deve implementar a contagem de zero até 60 segundos, mostrando a unidade variando de zero a
nove e a dezena incrementado de zero a seis. A dezena só deve ser incrementada quando a unidade completar
cada ciclo de zero a nove. Quando chegar em 60, o próximo incremento deve zerar o display.

```assembly_x86
```

##Exercicio 3
3. Aproveitando a base de tempo de minutos do Timer 0, exercício realizado na experiência 4, e o resultado do
exercício 2 desta experiência, implemente o display de minutos (DISPs 1 e 2). Faça-os contar os minutos de zero
a 60. Mantenha os displays de segundos e você terá um relógio de minutos e segundos.

```assembly_x86
```

##Exercicio 4
4. DESAFIO! VAMOS MONTAR UM RELÓGIO COMPLETO? Utilize 2 displays para horas e outros 2 displays para
minutos. Selecione dois LEDs fora do PORTD para sinalizarem os segundos.

```assembly_x86
```

##Exercicio 5
5. Faça comentários e conclusões sobre essa experiência, dissertando sobre o seu aprendizado, o manuseio dos
materiais experimentais, o tempo de aula, a realização desses exercícios, entre outros.
